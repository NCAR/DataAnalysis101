<!DOCTYPE html><html>

<head>
<meta charset="utf-8">
<title>APPM2720Week6Lecture</title>
<style type="text/css">
body {
  font-family: Helvetica, arial, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  padding-top: 10px;
  padding-bottom: 10px;
  background-color: white;
  padding: 30px; }

body > *:first-child {
  margin-top: 0 !important; }
body > *:last-child {
  margin-bottom: 0 !important; }

a {
  color: #4183C4; }
a.absent {
  color: #cc0000; }
a.anchor {
  display: block;
  padding-left: 30px;
  margin-left: -30px;
  cursor: pointer;
  position: absolute;
  top: 0;
  left: 0;
  bottom: 0; }

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
  cursor: text;
  position: relative; }

h1:hover a.anchor, h2:hover a.anchor, h3:hover a.anchor, h4:hover a.anchor, h5:hover a.anchor, h6:hover a.anchor {
  background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA09pVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoMTMuMCAyMDEyMDMwNS5tLjQxNSAyMDEyLzAzLzA1OjIxOjAwOjAwKSAgKE1hY2ludG9zaCkiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OUM2NjlDQjI4ODBGMTFFMTg1ODlEODNERDJBRjUwQTQiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OUM2NjlDQjM4ODBGMTFFMTg1ODlEODNERDJBRjUwQTQiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo5QzY2OUNCMDg4MEYxMUUxODU4OUQ4M0REMkFGNTBBNCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo5QzY2OUNCMTg4MEYxMUUxODU4OUQ4M0REMkFGNTBBNCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PsQhXeAAAABfSURBVHjaYvz//z8DJYCRUgMYQAbAMBQIAvEqkBQWXI6sHqwHiwG70TTBxGaiWwjCTGgOUgJiF1J8wMRAIUA34B4Q76HUBelAfJYSA0CuMIEaRP8wGIkGMA54bgQIMACAmkXJi0hKJQAAAABJRU5ErkJggg==) no-repeat 10px center;
  text-decoration: none; }

h1 tt, h1 code {
  font-size: inherit; }

h2 tt, h2 code {
  font-size: inherit; }

h3 tt, h3 code {
  font-size: inherit; }

h4 tt, h4 code {
  font-size: inherit; }

h5 tt, h5 code {
  font-size: inherit; }

h6 tt, h6 code {
  font-size: inherit; }

h1 {
  font-size: 28px;
  color: black; }

h2 {
  font-size: 24px;
  border-bottom: 1px solid #cccccc;
  color: black; }

h3 {
  font-size: 18px; }

h4 {
  font-size: 16px; }

h5 {
  font-size: 14px; }

h6 {
  color: #777777;
  font-size: 14px; }

p, blockquote, ul, ol, dl, li, table, pre {
  margin: 15px 0; }

hr {
  background: transparent url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAECAYAAACtBE5DAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBNYWNpbnRvc2giIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OENDRjNBN0E2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OENDRjNBN0I2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo4Q0NGM0E3ODY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo4Q0NGM0E3OTY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PqqezsUAAAAfSURBVHjaYmRABcYwBiM2QSA4y4hNEKYDQxAEAAIMAHNGAzhkPOlYAAAAAElFTkSuQmCC) repeat-x 0 0;
  border: 0 none;
  color: #cccccc;
  height: 4px;
  padding: 0;
}

body > h2:first-child {
  margin-top: 0;
  padding-top: 0; }
body > h1:first-child {
  margin-top: 0;
  padding-top: 0; }
  body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0; }
body > h3:first-child, body > h4:first-child, body > h5:first-child, body > h6:first-child {
  margin-top: 0;
  padding-top: 0; }

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0; }

h1 p, h2 p, h3 p, h4 p, h5 p, h6 p {
  margin-top: 0; }

li p.first {
  display: inline-block; }
li {
  margin: 0; }
ul, ol {
  padding-left: 30px; }

ul :first-child, ol :first-child {
  margin-top: 0; }

dl {
  padding: 0; }
  dl dt {
    font-size: 14px;
    font-weight: bold;
    font-style: italic;
    padding: 0;
    margin: 15px 0 5px; }
    dl dt:first-child {
      padding: 0; }
    dl dt > :first-child {
      margin-top: 0; }
    dl dt > :last-child {
      margin-bottom: 0; }
  dl dd {
    margin: 0 0 15px;
    padding: 0 15px; }
    dl dd > :first-child {
      margin-top: 0; }
    dl dd > :last-child {
      margin-bottom: 0; }

blockquote {
  border-left: 4px solid #dddddd;
  padding: 0 15px;
  color: #777777; }
  blockquote > :first-child {
    margin-top: 0; }
  blockquote > :last-child {
    margin-bottom: 0; }

table {
  padding: 0;border-collapse: collapse; }
  table tr {
    border-top: 1px solid #cccccc;
    background-color: white;
    margin: 0;
    padding: 0; }
    table tr:nth-child(2n) {
      background-color: #f8f8f8; }
    table tr th {
      font-weight: bold;
      border: 1px solid #cccccc;
      margin: 0;
      padding: 6px 13px; }
    table tr td {
      border: 1px solid #cccccc;
      margin: 0;
      padding: 6px 13px; }
    table tr th :first-child, table tr td :first-child {
      margin-top: 0; }
    table tr th :last-child, table tr td :last-child {
      margin-bottom: 0; }

img {
  max-width: 100%; }

span.frame {
  display: block;
  overflow: hidden; }
  span.frame > span {
    border: 1px solid #dddddd;
    display: block;
    float: left;
    overflow: hidden;
    margin: 13px 0 0;
    padding: 7px;
    width: auto; }
  span.frame span img {
    display: block;
    float: left; }
  span.frame span span {
    clear: both;
    color: #333333;
    display: block;
    padding: 5px 0 0; }
span.align-center {
  display: block;
  overflow: hidden;
  clear: both; }
  span.align-center > span {
    display: block;
    overflow: hidden;
    margin: 13px auto 0;
    text-align: center; }
  span.align-center span img {
    margin: 0 auto;
    text-align: center; }
span.align-right {
  display: block;
  overflow: hidden;
  clear: both; }
  span.align-right > span {
    display: block;
    overflow: hidden;
    margin: 13px 0 0;
    text-align: right; }
  span.align-right span img {
    margin: 0;
    text-align: right; }
span.float-left {
  display: block;
  margin-right: 13px;
  overflow: hidden;
  float: left; }
  span.float-left span {
    margin: 13px 0 0; }
span.float-right {
  display: block;
  margin-left: 13px;
  overflow: hidden;
  float: right; }
  span.float-right > span {
    display: block;
    overflow: hidden;
    margin: 13px auto 0;
    text-align: right; }

code, tt {
  margin: 0 2px;
  padding: 0 5px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px; }

pre code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent; }

.highlight pre {
  background-color: #f8f8f8;
  border: 1px solid #cccccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px; }

pre {
  background-color: #f8f8f8;
  border: 1px solid #cccccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px; }
  pre code, pre tt {
    background-color: transparent;
    border: none; }

sup {
    font-size: 0.83em;
    vertical-align: super;
    line-height: 0;
}
* {
	-webkit-print-color-adjust: exact;
}
@media screen and (min-width: 914px) {
    body {
        width: 854px;
        margin:0 auto;
    }
}
@media print {
	table, pre {
		page-break-inside: avoid;
	}
	pre {
		word-wrap: break-word;
	}
}
</style>
</head>
<body>
<h3 id="toc_0">APPM2720 Week 6 Lecture: More about reading data and working with images</h3>

<p>This lecture gives some typical examples of reading in data
and reformatting for analysis in R. To make this more relevant the focus is on image data.
To work through these examples you will need to install the <strong>fields</strong>,
<strong>raster</strong>, and <strong>jpeg</strong> R packages (in Rstudio <em>tools -&gt; Install packages</em>)</p>

<h3 id="toc_1">Overview</h3>

<p>As way to organize thoughts on this topic think about
the image format as being most useful for representing 
2-d surfaces and other data on a 2-d grid. The raster format is better for photos and other images where the
main use is to overlay them on top of other information. Image format is the one for computing and 
statistics and raster format is a more attractive and faster plotting mode for viewing images. You can translate between the two forms but this is usually not necessary since they have different purposes.</p>

<h3 id="toc_2">About image formats in R</h3>

<ul>
<li>An <em>image matrix</em> in R has two subscripts that index the pixels of the image. All images are assumed to be rectangular although sometimes the pixel sizes can be unequal in the X and Y directions. For the data set <code>lennon</code> has values that are assumed to be the shades of grey on a scale from 0 to 255.
Where 0 is black and 255 is white. </li>
</ul>

<p>In the image format:</p>

<ul>
<li><p>lennon[1,1] is the value in the
bottom left</p></li>
<li><p>lennon[256,1] the bottom right </p></li>
<li><p>lennon[1, 256] the top left </p></li>
<li><p>lennon[256,256] top right </p></li>
</ul>

<div><pre><code class="language-none">library( fields)
data(lennon)
dim( lennon)
range( c( lennon))</code></pre></div>

<p>The dimensions are 256X256 and  the range is actually [0,192]. To find the values in particular values you can use subscripting:
lennon[1:128, 1:128] would give you just a quarter of the image. </p>

<ul>
<li><p>An extension of an image matrix includes two arrays that indicate the scale of the rows and columns. This is not as useful for say a photo.  For images where the pixels are grid of longitudes and latitudes this is invaluable especially when a map needs to be added on top of the image.</p>

<p>The image format is a list with components 
<strong>x</strong>, <strong>y</strong> and <strong>z</strong>.
For the lennon image the list would be</p></li>
</ul>

<div><pre><code class="language-none">lennon2 &lt;- list( x= 1:256, y=1:256,z=lennon)</code></pre></div>

<p>here the z component is the 256X256 image matrix that was considered above. 
Using this as <code>image(lennon2)</code> will automatically scale the axis according to x and y. </p>

<p>The way to remember where everything goes is 
the pixel z[i,j] will be located at the point x[i], y[j]
in the image plot. So the pixel lennon[23,45] will be at the point 23, 45 in the plot. </p>

<h3 id="toc_3">Reshaping data as matrices and arrays</h3>

<p>Images are great examples for reading in an array of values and getting in the right format for visualizing.
The file <strong>lennonRaw.txt</strong> is a dump of the lennon image values, column by column but written 10 values to a line.</p>

<p>Here are some steps to read it in.</p>

<div><pre><code class="language-none">tempData&lt;- scan( &quot;lennonRaw.txt&quot;)
test1&lt;- matrix( tempData, ncol=256, nrow=256)
# or 
test1&lt;- array( tempData, c( 256, 256))</code></pre></div>

<ul>
<li>Switch the roles of the rows and columns. The image will be flipped around the diagonal. This is the most common issue in reading in images.<br></li>
</ul>

<div><pre><code class="language-none">test2&lt;- aperm( test1, c(2,1))</code></pre></div>

<p>See the R script <strong>readImages.R</strong>
for other examples of modifying the image, e.g. rotating 90 degrees and flipping left to right or top to bottom. </p>

<h3 id="toc_4">Using the image and image.plot functions</h3>

<p>To plot this image we use the image function. This function assumes a default color scale that is good for data 
analysis but not good for black and white photos. A better choice is a  to  256 grey values 
ranging form black (0) to white (1.0).
The code below gives a sequence on more elaborate
modifications to the image plot. Note the last one gives a useful legned to indicate how the image values are mapped to the grey levels. </p>

<div><pre><code class="language-none">data(lennon)
image(lennon) # default colors 
greyScale&lt;-  grey( seq(0,1,,256))
image(lennon , col= greyScale)
# change the coordinates to be in &quot;pixels&quot;
image(1:256, 1:256,lennon , col= greyScale)
# add a color scale to indcate the grey levels 
image.plot(1:256, 1:256,lennon, col= greyScale, xlab=&quot;&quot;, ylab=&quot;&quot;)</code></pre></div>

<p>Here is a slightly different version that makes it mode like a photo. The zlim argument means map the grey scale
to the range 0 to 255. Since the actual image only goes up to 192 we see that even the brightest parts are still
sort of grey. </p>

<div><pre><code class="language-none"># make this more like a photo
par( mar=c(1,1,1,1)) # small margins
image(1:256, 1:256,lennon, col= greyScale, axes=FALSE,
 xlab=&quot;&quot;, ylab=&quot;&quot;, zlim =c(0,255) )</code></pre></div>

<p>The advantage of bringing an image into R is that you still do 
data analysis and statistics on the numerical values and pixel locations.</p>

<div><pre><code class="language-none"># add a horiontal lines at pixel 100 and 200
image.plot(1:256, 1:256,lennon, col= greyScale, xlab=&quot;&quot;, ylab=&quot;&quot;)
abline( h=c(100,200), col=&quot;magenta&quot;)</code></pre></div>

<p>plot a subset of the image</p>

<div><pre><code class="language-none">testImage&lt;- lennon[1:200,1:100]
image(1:200, 1:100, testImage,
 col= greyScale)</code></pre></div>

<p>Use the zlim to force this to use the same range of grey levels as the full image. </p>

<p>You can always turn pixel values to white by making them NAs 
<code>
testImage&lt;- lennon
testImage[ lennon&lt; 10] &lt;- NA
</code></p>

<p>or do other other arithmetic with the image matrix.
For example to emphasize the brighter parts of the image you could plot the square root of the image values
(e.g. <code>testImage &lt;-  lennon^(.5)</code> ). </p>

<h3 id="toc_5">Reading in color images</h3>

<p>The file <strong>RlogoRaw.txt</strong> is an 76X100 image that has three
color channels (actually 3 images). To read this in</p>

<div><pre><code class="language-none">tempData&lt;- scan( &quot;RlogoRaw.txt&quot;)
test1&lt;- array( tempData, c(76,100,3))</code></pre></div>

<p>Each of <code>test1[,,1] , test1[,,2], test1[,,3]</code> is a separate 76X100 image matrix and represent the color
channels red , green and blue (RGB).</p>

<p>The file <strong>RlogoRaw.jpg</strong> is the original jpeg image for the Rlog and can be read  in R by 
<code>
library(jpeg)
test2&lt;- readJPEG(&quot;Rlogo.jpg&quot;)
</code>
The objects <strong>test1</strong> and <strong>test2</strong> are the same! To plot these in R you will need to use the raster package to combine the color channels into the actual color at each pixel. (see next section)</p>

<p>To read in an image in the the png format:
<code>
library(png)
test3&lt;- readPNG(&quot;Rlogo.png&quot;)
</code>
Because the png format is different than the jpeg
<strong>test2</strong> and <strong>test3</strong> are slightly different. </p>

<h3 id="toc_6">Working with raster format and the raster package</h3>

<p>The raster package is designed for images that are akin to phots and less for manipuating them as matrices. 
Plotting raster images is easy.</p>

<div><pre><code class="language-none">tempData&lt;- scan( &quot;RlogoRaw.txt&quot;)
test1&lt;- array( tempData/255, c(76,100,3))
testRaster&lt;- as.raster( test1)
plot(testRaster) </code></pre></div>

<p><strong>plot</strong> in this case exploits the raster format and makes an image instead of the default scatterplot. </p>

<p>The image plots much faster but the &quot;values&quot; in testRaster are now characters indicating the color directly. So you can not do arithmetic on them. </p>

<p>In the raster format:</p>

<ul>
<li><p>testRaster[1,1] is the value in the
top left</p></li>
<li><p>testRaster[256,1] the bottom left </p></li>
<li><p>testRaster[1, 256] the top left </p></li>
<li><p>testRaster[256,256] bottom right</p></li>
</ul>

<p>If you want to manipulate an image you should read it in 
as the array of 3 image matrices, modify these, then 
convert to the raster format to plot.</p>

<h3 id="toc_7">Working with RGB colors</h3>

<p>The file <code>Rlogo.jpg</code> is a JPEG image of the R logo. 
As mentioned above when this is read into R the result is three different image matrices indicating the mix of red, green and blue colors at each pixel. 
The three different images are the red, blue and green channels that define the colors. Every color in R can be 
described by the levels of RBG. The levels are between [0,1] or [0, 255] depending on the function and defaults. 
Grey is defined by the RGB levels being equal ( e.g. c(.5,.5,.5) is a medium grey. The <strong>as.raster</strong> function  combines these numerical values into a color code that is a character string. The <strong>rgb</strong> function in R can also be used to do this. 
For example to convert RGB 255, 62, 150.
we have </p>

<div><pre><code class="language-none">rgb( 255, 62,150, maxColorValue=255)
[1] &quot;#FF3E96&quot;</code></pre></div>

<p>Technically &quot;#FF3E96&quot; is a character that indicates 3, two digit numbers in hexadecimal (base 16). </p>

<p>The important concept however, is the raster format represents the assembled color for each pixel using these color codes and this is why one can not manipulate the image when is it is the raster format. </p>

<h3 id="toc_8">Aside about color names.</h3>

<p>Another way to describe colors is by their name see <strong>colors()</strong> for a listing of colors in R. You can use <strong>col2rgb</strong>* to convert and a color name to the rgb code and of course this is done internally by R whenever a color is specified in this way in a plot function. These kinds of names do not make sense in the raster format, however, because we are expecting the kind of arbitrary colors that would be present in a color photo. </p>

<div><pre><code class="language-none">col2rgb( &quot;violetred1&quot;)
      [,1]
red    255
green   62
blue   150</code></pre></div>

<script type="text/x-mathjax-config">
if (typeof MathJaxListener !== 'undefined') {
  MathJax.Hub.Register.StartupHook('End', function () {
    MathJaxListener.invokeCallbackForKey_('End');
  });
}
</script>
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>

</html>
