obj<- LKrig( x,y,NC=5, weights= weights, lambda=lambda,nlevel=nlevel,alpha=alpha,a.wght=a.wght,
NtrA=5,iseed=122)
LKinfo<- obj$LKinfo
# now check these formulas as implemented in LatticeKrig
obj0<- mKrig( x,y, weights= weights, lambda=lambda, m=2, cov.function="LKrig.cov",
cov.args=list(LKinfo=LKinfo),
NtrA=5, iseed=122)
options( echo=TRUE)
remove( list=ls())
data( ozone2)
x<-ozone2$lon.lat[1:20,]
y<- ozone2$y[16,1:20]
good <-  !is.na( y)
x<- x[good,]
y<- y[good]
#x<- transformx(x, "range")
N<- length( y)
lambda <- .8
set.seed(123)
weights<- runif(N)
W<- diag(weights)
# a micro sized lattice so determinant is not too big or small
obj<- LKrig( x,y,NC=5, weights= weights, lambda=lambda,nlevel=nlevel,alpha=alpha,a.wght=a.wght,
NtrA=5,iseed=122)
LKinfo<- obj$LKinfo
# now check these formulas as implemented in LatticeKrig
obj0<- mKrig( x,y, weights= weights, lambda=lambda, m=2, cov.function="LKrig.cov",
cov.args=list(LKinfo=LKinfo),
NtrA=5, iseed=122)
library( LatticeKrig)
options( echo=FALSE)
# tests for computing the determinant and quad form
test.for.zero.flag<- 1
alpha<- c(1,.5,.5)
nlevel<-3
a.wght<-  c(5,5,10)
lnDet<- function(A){
sum( log( eigen( A, symmetric=TRUE)$values))}
data( ozone2)
x<-ozone2$lon.lat[1:20,]
y<- ozone2$y[16,1:20]
good <-  !is.na( y)
x<- x[good,]
y<- y[good]
#x<- transformx(x, "range")
N<- length( y)
lambda <- .8
set.seed(123)
weights<- runif(N)
W<- diag(weights)
# a micro sized lattice so determinant is not too big or small
obj<- LKrig( x,y,NC=5, weights= weights, lambda=lambda,nlevel=nlevel,alpha=alpha,a.wght=a.wght,
NtrA=5,iseed=122)
LKinfo<- obj$LKinfo
# now check these formulas as implemented in LatticeKrig
obj0<- mKrig( x,y, weights= weights, lambda=lambda, m=2, cov.function="LKrig.cov",
cov.args=list(LKinfo=LKinfo),
NtrA=5, iseed=122)
options(echo=TRUE)
names( obj)
names(obj0)
test.for.zero( obj$lnProfileLike.FULL,obj0$lnProfileLike.FULL,
tag="lnProfileFULL from LKrig and identical compuation
using mKrig")
source('~/Home/Src/LatticeKrig/tests/LKrig.lnPLike.test.R', echo=TRUE)
remove( list=ls())
source('~/Home/Src/LatticeKrig/tests/LKrig.test.R', echo=TRUE)
options( echo=TRUE)
LKrig.lnPlike
LKrig.lnPlikeNEW
remove( list=ls())
source('~/Home/Src/LatticeKrig/tests/LKrig.test.R', echo=TRUE)
look2
rm( obj) # remove previous objects
data( ozone2)
x<-ozone2$lon.lat[1:10,]
y<- ozone2$y[16,1:10]
good <-  !is.na( y)
x<- x[good,]
y<- y[good]
#x<- transformx(x, "range")
N<- length( y)
lambda <- .8
# a micro sized lattice so determinant is not too big or small
obj<- LKrig( x,y,NC=5, lambda=lambda,nlevel=nlevel,alpha=alpha,a.wght=a.wght,
NtrA=5,iseed=122)
obj0<- mKrig( x,y, lambda=lambda, m=2, cov.function="LKrig.cov",
cov.args=list(LKinfo=obj$LKinfo),
NtrA=20, iseed=122)
test.for.zero( obj$lnDetCov,obj0$lnDetCov, tag= "lnDetCov for mKrig and LatticeKrig")
test.for.zero( obj$quad.form,  obj0$quad.form, tag= "quadratic forms for rho hat")
test.for.zero(  obj0$lnProfileLike, obj$lnProfileLike,
tag="Profile Likelihood concentrated on lambda" )
data( ozone2)
x<-ozone2$lon.lat[1:20,]
y<- ozone2$y[16,1:20]
good <-  !is.na( y)
x<- x[good,]
y<- y[good]
N<- length(y)
set.seed(243)
weights<- runif(N)*10
#x<- transformx(x, "range")
N<- length( y)
alpha<- c(1,.5,.5)
nlevel<-3
a.wght<-  c(5,5,10)
lambda <- .8
obj<- LKrig( x,y,weights=weights,NC=15, lambda=lambda,alpha=alpha,
nlevel=nlevel,a.wght=a.wght, return.cholesky=TRUE)
obj2<- LKrig( x,y,weights=weights,NC=15, lambda=2*lambda,alpha=alpha,
nlevel=nlevel,a.wght=a.wght, use.cholesky=obj$Mc)
obj3<-  LKrig( x,y,weights=weights,NC=15, lambda=2*lambda,alpha=alpha,
nlevel=nlevel,a.wght=a.wght, return.cholesky=TRUE)
test.for.zero( obj3$c.coef, obj2$c.coef, tag="test of LatticeKrig.coef c")
test.for.zero( obj3$d.coef, obj2$d.coef, tag="test of LatticeKrig.coef d")
Q<- LKrig.precision(obj3$LKinfo)
look2<-LKrig.lnPlikeOLD(obj3$Mc,Q,sqrt(weights)*y, obj3$residuals,
weights, obj3$LKinfo)
look2
sqrt(weights)*y
obj3$residuals
obj3$LKinfo
look2<-LKrig.lnPlike(obj3$Mc,Q, obj3$quad.form, nObs=N, nReps=1, weights, LKinfo)
test.for.zero( look2$lnProfileLike, obj3$lnProfileLike)
obj3$lnProfileLike
obj$lnProfileLike
obj2$lnProfileLike
obj<- LKrig( x,y,weights=weights,NC=15, lambda=lambda,alpha=alpha,
nlevel=nlevel,a.wght=a.wght, return.cholesky=TRUE)
obj2<- LKrig( x,y,weights=weights,NC=15, lambda=2*lambda,alpha=alpha,
nlevel=nlevel,a.wght=a.wght, use.cholesky=obj$Mc)
obj$lambda.fixed
obj$lambda.fixed
obj2$lambda.fixed
summary( obj)
q()
obj
obj2
obj3<-  LKrig( x,y,weights=weights,NC=15, lambda=2*lambda,alpha=alpha,
nlevel=nlevel,a.wght=a.wght, return.cholesky=FALSE)
test.for.zero( obj3$c.coef, obj2$c.coef,
tag="reuse Mc test of LatticeKrig.coef c")
test.for.zero( obj3$d.coef, obj2$d.coef,
tag="reuse Mctest of LatticeKrig.coef d")
test.for.zero( obj2$lnProfileLike, obj3$lnProfileLike,
tag="reuse Mc test of lnProfileLike")
ls()
prompt( LKrig)
help( "pairs")
set.seed( 123)
# the power of multiple regression
X1<- rnorm(100)
X2<- rnorm( 100)
X3<- rnorm( 100)
# Y is perfectly predictable if you know X1,X2, X3
Y<- X1 + 2*X2 -.5*X3
testData<- data.frame( X1, X2, X3, Y)
pairs( testData)
set.seed( 123)
# the power of multiple regression
X1<- rnorm(100)
X2<- rnorm( 100)
X3<- rnorm( 100)
# Y is perfectly predictable if you know X1,X2, X3
Y<- X1 + 1.2*X2 -.5*X3
testData<- data.frame( X1, X2, X3, Y)
pairs( testData)
summary( lm(Y ~ X1))
plot( X2, fit1$residuals)
fit1<- lm( Y~ X1)
summary( fit1)
plot( X2, fit1$residuals)
set.panel( 1,2)
plot( X2, fit1$residuals)
plot( X3, fit1$residuals)
library( fields)
set.panel( 1,2)
plot( X2, fit1$residuals)
plot( X3, fit1$residuals)
fit2<- lm( Y~ X1 + X2)
summary( fit2)
plot( X3, fit2$residuals)
set.seed( 123)
# the power of multiple regression
X1<- rnorm(20)
X2<- rnorm( 20)
X3<- rnorm( 20)
# Y is perfectly predictable if you know X1,X2, X3
Y<- X1 + 1.2*X2 -.5*X3
testData<- data.frame( X1, X2, X3, Y)
# all pairwise scatter plots
pairs( testData)
fit1<- lm( Y~ X1)
summary( fit1)
set.panel( 1,2)
plot( X2, fit1$residuals)
plot( X3, fit1$residuals)
fit2<- lm( Y~ X1 + X2)
plot( X3, fit2$residuals)
fit3<- lm( Y ~ X1 +X2 +X3)
summary( fit3)
X1<- rnorm(20)
X2<- rnorm( 20)
X3<- rnorm( 20)
# Y is  almost perfectly predictable if you know X1,X2, X3
Y<- X1 + 1.2*X2 -.5*X3 + .01*rnorm(20)
testData<- data.frame( X1, X2, X3, Y)
# all pairwise scatter plots
pairs( testData)
fit1<- lm( Y~ X1)
summary( fit1)
set.panel( 1,2)
plot( X2, fit1$residuals)
plot( X3, fit1$residuals)
fit2<- lm( Y~ X1 + X2)
plot( X3, fit2$residuals)
fit3<- lm( Y ~ X1 + X2 + X3)
summary( fit3)
fit1<- lm( Y~ X1)
summary( fit1)
set.seed( 123)
# the power of multiple regression
X1<- rnorm(20)
X2<- rnorm( 20)
X3<- rnorm( 20)
# Y is  almost perfectly predictable if you know X1,X2, X3
Y<- X1 + 1.2*X2 -.5*X3 + .01*rnorm(20)
testData<- data.frame( X1, X2, X3, Y)
pairs( testData)
fit1<- lm( Y~ X1)
summary( fit1)
source('~/Home/Teaching/APPM2720/Week8/multipleLS.R', echo=TRUE)
source('~/Home/Teaching/APPM2720/Week8/multipleLS.R', echo=TRUE)
args( lm)
help( pnorm)
M<- 95
pnorm( (1- .5*(M/100) ), lower.tail=FALSE)
qnorm( (1- .5*(M/100) ), lower.tail=FALSE)
qnorm( .975)
qnorm( .025, lowre.tail=FALSE)
qnorm( .025, lower.tail=FALSE)
qnorm( .5* (1- M/100), lower.tail=FALSE)
qnorm( .5* (1- M/100), lower.tail=FALSE)
M<- 99
qnorm( .5* (1- M/100), lower.tail=FALSE)
help( predict.lm)
fitA4<- lm( price ~ year + mileage + distance, data=AudiA4)
usedCar<- data.frame( mileage = 50000, year =2014,  distance =0)
predict( fitA4, newdata=usedCar)
predict( fitA4, newdata=usedCar, interval="prediction")
predict( fitA4, newdata=usedCar, se.fit=TRUE)
predict( fitA4, newdata=usedCar, interval="prediction")
(22770.74 - 34681.6)/1.96
sqrt(373^2 + 3005^2)
(22770.74 - 34681.6)/1.96/2
SE<- predict( fitA4, newdata=usedCar, se.fit=TRUE)
SE.prediction<- sqrt( (SE$se.fit)^2 + (SE$residual.scale)^2 )
SE.prediction
(22770.74 - 34681.6)/1.96/2
fitA4quad<- lm( price ~ year + I(year^2) + mileage + I(mileage^2), data=AudiA4)
SE2<- predict( fitA4quad, newdata=usedCar, se.fit=TRUE)
SE2
SE<- predict( fitA4, newdata=usedCar, se.fit=TRUE)
SE
set.seed( 123)
# the power of multiple regression
X1<- rnorm(20)
X2<- rnorm( 20)
# Y is  almost perfectly predictable if you know X1,X2, X3
Y<- X1 + 1.2*X2 -.5*X3 + .01*rnorm(20)
testData<- data.frame( X1, X2,  Y)
# all pairwise scatter plots
pairs( testData)
fit1<- lm( Y~ X1)
summary( fit1)
set.panel( 1,2)
plot( X2, fit1$residuals)
fit2<- lm( Y~ X1 + X2)
plot( fit2)
AudiA4[1,]
data( AudiA4)
pairs(AudiA4[,1:6])
N<- nrow( AudiA4)
N
N<- nrow( AudiA4)
set.seed( 223)
sub<- sample(1:N, N*.9, replace=FALSE )
sub
N<- nrow( AudiA4)
set.seed( 223)
sub<- sample(1:N, N*.9, replace=FALSE )
subData<- AudiA4[sub,]
fit1<- lm( price ~ year + mileage + I( mileage^2) +I(year^2), data=subData)
N<- nrow( AudiA4)
set.seed( 223)
sub<- sample(1:N, N*.9, replace=FALSE )
subData<- AudiA4[sub,]
fitSub<- lm( price ~ year + mileage + I( mileage^2) +I(year^2), data=subData)
# the data NOT as the subset
outData<- AudiA4[-sub,]
pred<- predict( fitSub,outData )
plot( pred, outData$price)
abline( 0,1)
sd(  pred -outData$price)
fit1$sigma
summary( fitSub)
source('~/Home/Teaching/APPM2720/Week8/multipleLS.R', echo=TRUE)
source('~/Home/Teaching/APPM2720/Week8/multipleLS.R', echo=TRUE)
quilt.plot( AudiA4[,c("year", "mileage")] , AudiA4$price)
set.panel()
quilt.plot( AudiA4[,c("year", "mileage")] , AudiA4$price)
quartz()
quilt.plot( AudiA4[,c("year", "mileage")] , AudiA4$price)
quilt.plot( AudiA4[,c("year", "mileage")] , fit0$residuals)
library( dataWOrkshop)
library( dataWorkshop)
data()
data("WorldBankCO2")
help( WorldBankCO2)
plot( WorldBankCO2[,"GDP.cap"], WorldBankCO2[,"CO2.cap"], log="xy")
plot( WorldBankCO2[,"GDP.cap"], WorldBankCO2[,"CO2.cap"], log="x")
plot( WorldBankCO2[,"GDP.cap"], WorldBankCO2[,"CO2.cap"], log="y")
WB<- WorldBankCO2
WB[1,]
ls()
remove( list=ls())
library( dataWorkshop)
data( AudiA4)
x<- cbind( AudiA4$mileage,AudiA4$year )
obj<- Tps(cbind( AudiA4$mileage,AudiA4$year ), AudiA4$price )
surface( obj)
sd( obj$resdiuals)
sd( obj$residuals)
args( scan)
help( scan)
library( dataWorkshop)
data()
help( YSUsers)
data(YSUsers)
YSUsers[1,]
plot( YSUsers$queue_wait_time ~ YSUsers$num_cores_used)
plot( YSUsers$queue_wait_time ~ YSUsers$num_cores_used, log="y")
plot( YSUsers$queue_wait_time ~ YSUsers$num_cores_used, log="y", log="x")
plot( YSUsers$queue_wait_time ~ YSUsers$num_cores_used, log="xy")
wallTime<- YSUsers[,"end_time"] - YSUsers[,"start_time"]
cores<- YSUsers[,"num_nodes_used"] * 16
plot( wallTime, cores, log="xy", xlab="Time running", ylab="Number of cores")
boxplot(wallTime ~ as.factor( cores))
boxplot(wallTime ~ as.factor( cores), log="xy")
boxplot(wallTime ~ as.factor( cores), log="y")
names( YSUsers)
library( dataWorkshop)
data( AduiA4)
data( AudiA4)
AudiA4[1,]
AudiA4$engine
ls(0)
ls()
ind<- AudiA4$engine =="NEWLY"
ind
ind<- which(AudiA4$engine =="NEWLY")
ind
getCar( ind)
getCar( ind[1])
getCar( 309)
getCar( ind[2])
ind<- which(AudiA4$engine =="Prestige")
ind
getCar(ind[1])
engine<- AudiA4$engine
table( engine)
is.numeric( engine)
is.factor( engine)
as.list( engine)
as.numeric( engine)
which (engine >2)
which (as.numeric(engine) >2)
is.numeric( AudiA4$engine)
is.numeric( AudiA4$engine)
is.character( AudiA4$engine)
is.factor( AudiA4$engine)
var1<- c( "red", "blue", "red", "green", "blue", "blue", NA)
var1F<- as.factor(var1)
var1F
va1
var1
var1<- c( "red", "blue", "red", "green", "blue", "blue", NA)
print(var1)
var1F<- as.factor(var1)
print( var1F)
look<- as.numeric( var1F)
print(look)
table( var1)
table( var1F)
levels<- unique( var1)
print( levels)
index2<- match( var1, levels)
print( index2)
args( unique)
help( "unique")
levels<- levels[-4]
levels<- unique( var1)
print( levels)
index2<- match( var1, levels)
print( index2)
levels<- levels[-4]
index2<- match( var1, levels)
index2
lm( price ~ engine, data=AudiA4 )
table( AudiA4$engine)
# Oops! Some of these are not engines.
AudiA4$engineNew<- AudiA4$engine
AudiA4$engineNew[ "Prestige" == AudiA4$engine] <- NA
AudiA4$engineNew[ "NEWLY" == AudiA4$engine] <- NA
table( AudiA4$engine)
1.8T     2.0T      3.0    NEWLY Prestige       SE
51      305        1        2        2        1
# Oops! Some of these are not engines.
AudiA4$engineNew<- AudiA4$engine
ind<- match( AudiA4$engine, c("NEWLY", "Prestige", "SE")
AudiA4$engineNew[ ind] <- NA
table( AudiA4$engineNew)
ind<- match( AudiA4$engine, c("NEWLY", "Prestige", "SE"))
AudiA4$engineNew[ ind] <- NA
table( AudiA4$engineNew)
ind
levels( engineNew<- AudiA4$engine)
engineNew<- AudiA4$engine
ind<- match( engineNew, levels(engineNEW)[3:5] )
ind<- match( engineNew, levels(engineNew)[3:5] )
ind
engineNew<- AudiA4$engine
ind<- as.numeric(engineNew) >= 3
AudiA4$engineNew[ ind] <- NA
table( AudiA4$engineNew)
table( AudiA4$engine)
1.8T     2.0T      3.0    NEWLY Prestige       SE
51      305        1        2        2        1
# Oops! Some of these are not engines and can not
# handle just one dat point for 3.0
engineNew<- AudiA4$engine
ind<- as.numeric(engineNew) >= 3
engineNew[ ind] <- NA
table( AudiA4$engineNew)
table(engineNew)
engineNew<- AudiA4$engine
ind<- as.numeric(engineNew) >= 3
engineNew[ ind] <- NA
engineNew <- as.factor( engineNew)
table( engineNew)
engineNew0<-  as.numeric(AudiA4$engine)
ind<- engineNew) >= 3
engineNew0[ ind] <- NA
levelsNew<- levels(AudiA4$engine)[1:2]
engineNew <- as.factor( engineNew0, levelsNew)
table(engineNew)
engineNew0<-  as.numeric(AudiA4$engine)
ind<- engineNew  >= 3
engineNew0[ ind] <- NA
engineNew0<-  as.numeric(AudiA4$engine)
ind<- engineNew0  >= 3
engineNew0[ ind] <- NA
levelsNew<- levels(AudiA4$engine)[1:2]
engineNew <- as.factor( engineNew0, levelsNew)
help( as.factor)
levelsNew
engineNew0<-  as.character(AudiA4$engine)
ind<- as.numeric(AudiA4$engine)
engineNew0[ ind >= 3] <- NA
engineNew <- as.factor( engineNew0)
table(engineNew)
lm( price ~ engineNew, data=AudiA4 )
summary( lm( price ~ engineNew, data=AudiA4 ))
predict(  lm( price ~ engineNew, data=AudiA4 ))[1:10]
unique( predict(  lm( price ~ engineNew, data=AudiA4 )))
unique( predict(  lm( price ~ engineNew, data=AudiA4 )))
(7339 + 15403)
lm( price ~ year + mileage + engineNew, data=AudiA4 )
summary(lm( price ~ year + mileage + engineNew, data=AudiA4 ))
out<- (lm( price ~ year + mileage + engineNew, data=AudiA4 ))
plot( out)
hist( AUdiA4$distance)
hist( AudiA4$distance)
distF<- as.factor( ( AudiA4$distance <= 250) )
lm( price ~ year + mileage + distF, data=AudiA4 )
distF<- as.factor( ( AudiA4$distance <= 250) )
lm( price ~ I(year-mean(year))  + mileage + distF, data=AudiA4 )
lm( price ~ I(year- mean(year))  + mileage + distF, data=AudiA4 )
min( year)
min( AudiA4$year)
lm( price ~ I(year - 1999)  + mileage + distF, data=AudiA4 )
library( LatticeKrig)
LKrigSetup
ls(pos=2)
setwd("~/Home/Teaching/APPM2720/Week10")
library(fields)
load("TornadoExample.RData")
ls()
names(UStornado)
remove( LKrig)
ls()
head(UStornado$year)
head(year)
attach(UStornado)
ls()
head(UStornado$year)
head(year)
#
source('~/Home/Teaching/APPM2720/Week10/TornadoAnalysis.R', echo=TRUE)
CO.torn.loc
25000*2000
