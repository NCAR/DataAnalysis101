obj2
names (obj1)
obj1$lambda.fixed
obj2<-LatticeKrig(x,c(yNew),LKinfo=LKinfo, lambda=obj1$lambda.fixed)
obj2
obj1$sigma.MLE
obj1$rho.MLE
obj2$sigma.MLE
obj2$rho.MLE
obj2b<- LKrig( x,c(yNew),LKinfo=LKinfo, lambda=obj1$lambda.fixed)
obj2b
plot( obj1$c.coef,obj2b$c.coef)
plot(obj1$c.coef,type="l")
lines(obj2b$c.coef,col="red")
library( fields)
x<- 1:10
rdist( x, x)
X<- cbind( x, x+5)
X<- X[1:5,]
X
rdist( X)
help( dyn.load)
rdist
library( fields)
data( lennon)
apply( lennon, 2, "mean")-> m1
apply( lennon, 1, "mean")-> m2
look<- outer( m1,m2,"+")
image(lennon, col=grey.colors( 200))
image(look, col=grey.colors( 200))
library(dataWorkshop)
data(BoulderDaily)
names(BoulderDaily)
BoulderDaily$time
boxplot( precip~month, BoudlerDaily)
boxplot( precip~month, BoulderDaily)
data( BoulderTemperature)
stats( BoulderTemperature)
tapply( BoulderDaily$precip, BoulderDaily$month, 'sum')
tapply( BoulderDaily$precip, BoulderDaily$month, 'sum', na.rm =TRUE)
tapply( BoulderDaily$precip, BoulderDaily$month, 'mean', na.rm =TRUE)
tapply( BoulderDaily$precip, BoulderDaily$month, 'mean', na.rm =TRUE)*30
data( BoulderTemperature)
row.names(BoulderTemperature)
as.numeric(row.names(BoulderTemperature))
apply( BoulderTemperature[,6:8], 2, "median")-> look
look
apply( BoulderTemperature[,6:8], 1, "median")-> look
look
plot( look)
yearLabel<- row.names(BoulderTemperature)
Year <- as.numeric(yearLabel)
Year
package.skeleton
help(package.skeleton)
packageskeleton("PETScR")
package.skeleton("PETScR")
dir()
pwd()
remove(list=ls())
package.skeleton("PETScR")
source('~/Home/Src/PETScR/R/ExpMultTest.R', echo=TRUE)
prompt( ExpMultTest.cov)
ExpMultTest.cov
source('~/Home/Src/PETScR/R/ExpMultTest.R', echo=TRUE)
set.seed( 123)
x1<- matrix( runif( 20), 10,2)
x2<- matrix( runif( 18),  9,2)
C<- matrix( rnorm(18*4), 18,4)
theta<- .5
look<- ExpMultTest.cov( x1,x2, theta, C)
ExpMultTest.cov( x1,x2, theta, C)
ExpMultTest.cov
set.seed( 123)
x1<- matrix( runif( 20), 10,2)
x2<- matrix( runif( 18),  9,2)
C<- matrix( rnorm(18*4), 18,4)
theta<- .5
look<- ExpMultTest.cov( x1,x2, theta, p=1, C=C)
library( fields)
set.seed( 123)
x1<- matrix( runif( 20), 10,2)
x2<- matrix( runif( 18),  9,2)
C<- matrix( rnorm(18*4), 18,4)
theta<- .5
look<- ExpMultTest.cov( x1,x2, theta, p=1, C=C)
look
Sigma<- exp(-rdist( x1,x2))
Sigma%*%C
dim( Sigma)
dim( C)
set.seed( 123)
x1<- matrix( runif( 20), 10,2)
x2<- matrix( runif( 18),  9,2)
C<- matrix( rnorm(9*4), 9,4)
theta<- .5
look<- ExpMultTest.cov( x1,x2, theta, p=1, C=C)
# compare to
Sigma<- exp(-rdist( x1,x2))
Sigma%*%C
look
dim( C)
Sigma<- exp(-rdist( x1,x2)/theta)
Sigma%*%C
look
set.seed( 123)
x1<- matrix( runif( 20), 10,2)
x2<- matrix( runif( 18),  9,2)
C<- matrix( rnorm(9*4), 9,4)
theta<- .5
look<- ExpMultTest.cov( x1,x2, theta, p=1, C=C)
# compare to
Sigma<- exp(-rdist( x1,x2)/theta)
look2<- Sigma%*% C
look
look2
set.seed( 123)
x1<- matrix( runif( 20), 10,2)
x2<- matrix( runif( 18),  9,2)
C<-  rnorm(9)
theta<- .5
look<- ExpMultTest.cov( x1,x2, theta, p=1, C=C)
# compare to
Sigma<- exp(-rdist( x1,x2)/theta)
look2<- Sigma%*% C
look
look2
rdist
load("~/Home/Teaching/RDataAnalysis/Week3/BoulderTemperature.rda")
dim( BoulderTemperature)
test<- c( 1,3,4.5, NA,10)
ind<- is.na(test)
sum( ind)
ls()
remove( list=ls())
save.image()
look<- matrix( 1:12, ncol=4, nrow=3)
look
look[2,3] <- NA
look
look2<- is.na( look)
look2
look[ look==4]
look==4
look==NA
is.numeric(look)
look<- matrix( 1:12, ncol=4, nrow=3)
look
look[2,3] <- NA
look
look2<- is.na( look)
look2
is.numeric(look)
look
apply( look, 1, "max")
apply( look, 1, "max", na.rm=TRUE)
apply( look, 2, "max")
look
image(1:3, 1:4, look, col=rainbow(256))
quartz()
image(1:3, 1:4, look, col=rainbow(256))
library( fields)
image.plot(1:3, 1:4, look, col=rainbow(256))
look[,1]
look[1,]
look
look[1:2, c(1,3)]
WB<- WorldBankCO2
library(dataWorkshop)
data(WorldBankCO2 )
WB<- WorldBankCO2
plot(CO2.cap ~ GDP.cap, data=WB, log="xy",
xlab="GDP", ylab="CO2")
quartz()
plot(CO2.cap ~ GDP.cap, data=WB, log="xy",
xlab="GDP", ylab="CO2")
x<- log10(WB$GDP.cap )
y<- log10( WB$CO2.cap)
plot( x,y, pch=16, col="grey", xlab="log 10 GDP", ylab="log 10 CO2")
x<- log10(WB$GDP.cap )
y<- log10( WB$CO2.cap)
plot( x,y, pch=16, col="grey", xlab="log 10 GDP", ylab="log 10 CO2")
x<- log10(WB$GDP.cap )
y<- log10( WB$CO2.cap)
plot( x,y, pch=16, col="grey", xlab="log 10 GDP", ylab="log 10 CO2")
x<- log10(WB$GDP.cap )
y<- log10( WB$CO2.cap)
plot( x,y, pch=16, col="grey", xlab="log 10 GDP", ylab="log 10 CO2")
library( spam)
library( help="spam")
help( "as.spam")
as.dgCMatrix.spam
library( spam)
help( "as.spam.dgCMatrix")
as.spam
as.spam.matrix.csr
chol
chol.default
temp<- matrix( 1:9, 3,3)
temp<- temp%*%t( temp)
temp
temp2<- chol( temp)
temp<- matrix( runif(9), 3,3)
temp<- temp%*%t( temp)
temp2<-chol( temp)
temp2
dump( temp2)
is.matrix( temp2)
attributes( temp2)
hekp( SET_SLOT)
help( SET_SLOT)
help( S4)
help( .Call)
library( Matrix)
help( as.sparse)
library( help=Matrix)
chol
showMethods( "chol")
slotNames
.slotNames
temp<- matrix( 1:9,3,3)
library( spam)
as.spam( temp)-> look
slotNames( look)
as.list( look)
dump( look)
dump( "look")
class( look)
slotNames
x@slots
look@slots
.slotNames( look)
.slotNames
isS4(look)
class( look)
getClassDef
help( classDef)
getClassDef("spam")
look
160*15
120*15
4800*1.1*1.5
library( Matrix)
sparseMatrix
help( ls)
library( spam)
ls( all.names=TRUE)
search()
ls( all.names=TRUE, pos=2)
as.spam.matrix.csr
source('~/Home/Teaching/APPM2720/Week4/RintroProgramming2.R', echo=TRUE)
mySmooth2<- function( x,y, span){
N<- length( x)
smooth<- rep( NA, N)
for( k in 1:N  ){
# two years on either side
ind <- abs( x - x[k]) <= span
smooth[k] <- median( y[ind], na.rm=TRUE )
}
result<- cbind(x, smooth)
}
library( dataWorkshop)
data( lennon)
set.seed( 123)
data( lennon)
lennonNoise<- lennon + matrix( rnorm(256^2) *50, 256, 256)
sImage<- matrix( NA, 256, 256)
span<- 4
for( k in 1:256){
sImage[k,]<- mySmooth2( 1:256, lennonNoise[k,], span )[,2]
}
for( j in 1:256){
sImage[,j]<- mySmooth2( 1:256,sImage[,j], span )[,2]
}
set.panel( 1,3)
image( lennon, col=grey.colors( 256))
image( lennonNoise, col=grey.colors( 256))
image( sImage, col=grey.colors( 256))
mySmooth<- function( x,y, span){
N<- length( x)
smooth<- rep( NA, N)
for( k in 1:N  ){
# two years on either side
ind <- abs( x - x[k]) <= span
smooth[k] <- mean( y[ind], na.rm=TRUE )
}
result<- cbind(x, smooth)
}
mySmooth2<- function( x,y, span){
N<- length( x)
smooth<- rep( NA, N)
for( k in 1:N  ){
# two years on either side
ind <- abs( x - x[k]) <= span
smooth[k] <- median( y[ind], na.rm=TRUE )
}
result<- cbind(x, smooth)
}
set.seed( 123)
data( lennon)
lennonNoise<- lennon + matrix( rnorm(256^2) *50, 256, 256)
sImage1<- matrix( NA, 256, 256)
span<- 4
for( k in 1:256){
sImage1[k,]<- mySmooth( 1:256, lennonNoise[k,], span )[,2]
}
for( j in 1:256){
sImage1[,j]<- mySmooth( 1:256,sImage1[,j], span )[,2]
}
sImage2<- matrix( NA, 256, 256)
span<- 4
for( k in 1:256){
sImage2[k,]<- mySmooth2( 1:256, lennonNoise[k,], span )[,2]
}
for( j in 1:256){
sImage2[,j]<- mySmooth2( 1:256,sImage2[,j], span )[,2]
}
set.panel( 2,2)
image( lennon, col=grey.colors( 256))
image( lennonNoise, col=grey.colors( 256))
image( sImage1, col=grey.colors( 256))
image( sImage2, col=grey.colors( 256))
quartz()
set.panel( 2,2)
image( lennon, col=grey.colors( 256))
image( lennonNoise, col=grey.colors( 256))
image( sImage1, col=grey.colors( 256))
image( sImage2, col=grey.colors( 256))
sImage1<- matrix( NA, 256, 256)
span<- 6
for( k in 1:256){
sImage1[k,]<- mySmooth( 1:256, lennonNoise[k,], span )[,2]
}
for( j in 1:256){
sImage1[,j]<- mySmooth( 1:256,sImage1[,j], span )[,2]
}
sImage2<- matrix( NA, 256, 256)
span<- 4
for( k in 1:256){
sImage2[k,]<- mySmooth2( 1:256, lennonNoise[k,], span )[,2]
}
for( j in 1:256){
sImage2[,j]<- mySmooth2( 1:256,sImage2[,j], span )[,2]
}
set.panel( 2,2)
image( lennon, col=grey.colors( 256))
image( lennonNoise, col=grey.colors( 256))
image( sImage1, col=grey.colors( 256))
image( sImage2, col=grey.colors( 256))
source('~/Home/Src/LatticeKrig/R/ModelRing.R', echo=TRUE)
library( fields)
cite( fields)
citation( "fields")
dataWorkshop()
library( dataWorkshop)
myFunction<-function(x){
naVariables<- is.na(x)
sumNa<-sum(naVariables)
return(sumNa)
}
myFunction(BoulderTemperature)
data(BoulderTemperature)
myFunction(BoulderTemperature)
apply( BouldwrTemperature, 2, myFunction)
apply( BoulderTemperature, 2, myFunction)
setwd("~/Home/Teaching/APPM2720/Quizes")
setwd("~/Home/Teaching/APPM2720/Quizes")
load("BT.rda")
ls()
apply( BoulderTemperature, 2, myMissing)
myMissing<- function(x){
countNA<- sum( is.na(x))
return( countNA)
}
apply( BoulderTemperature, 2, myMissing)
data( BoulderTemperature)
library( dataWorkshop)
data( BoulderTemperature)
apply( BoulderTemperature, 2, myMissing)
